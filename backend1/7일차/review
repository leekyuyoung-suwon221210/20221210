클래스  1개
	정의 : 붕어빵틀
	구성요소
		변수(전역변수) : 자동초기화
		메소드
			변수(지역변수) : 자동초기화 아님
		자기자신을 나타내는 객체 : this 가 있고.. 함수의 파라메터이름과 클래스 변수의 이름이 같을때 구분하기위해
							사용 ex) this.name = name	


객체  여러개
	정의 : 붕어빵
	만드는방법
		클래스명 객체명 = new 클래스명()
		생성자 : ex) 클래스명()
			역활 및 기능 : 객체를 생성할때 자동으로 호출되고 그 이후에 객체 생성
						대표적인 overloading
						리턴타입이 없다.. void를  사용하는게 아니라 아예 코딩을 안한다
						생성자에서는 초기화 작업을 한다.
						생성자는 사용자가 호출할수 없고 호출하려면 또 다른 생성자 안에서 사용한다.
						이때 반드시 첫번째 코드로 사용해야 한다.
			생성자 호출방법 :  this(), this(a,b,c) 등등.
			기본    생성자: 사용자가 생성자를 안만들면.. 모든 클래스는 기본생성자를 제공(은닉)
			매개변수 생성자: 사용자가 만드는 생성자... 사용자가 만들면 기본생성자는 없어짐.. 따라서 만들어줘야함

객체 지향의 특징
	캡슐화 : 은닉의 성격
		캡슐화 하는법 : private를 붙인다. 주로 변수에.
		?? 그러면 변수에 값을 외부에서 어떻게 읽고 쓸수 있을까? --> public 한 getter setter 메소드를 제공한다.
	오버로드 : 과적  메소드명은 같고 매개변수의 개수나 형태가 다를때
		--> 이름이 같아도.. 매개변수로 구분이 가능하기때문에 허용
		--> 한 반에 홍길동이 2명있으면.. 큰홍길동 작은홍길동 또는 학생번호로 불렸던 기억이.....
		메소드명()
		메소드명(int a)
		메소드명(int a, int b)
		
번외 : 클래스의 맴버변수가 많아서 다양한 초기화를 필요로 할때  생성자를 이용하면
	경우의 수 만큼 생성자를 만들어 줘야함
	해결방법 : 메소드 체이닝 기법을 사용
			setter 함수를 void가 아닌 객체를 리턴하게 설계한다.
			setA(2).setB(3). ...... 이런식으로 사용함
	
			
		